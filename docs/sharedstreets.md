# SharedStreets

*[(Back to Docs Catalog)](index.md)*

This document outlines the investigation so far on using SharedStreets in the ATD Data Lake project. These are compilations of notes and code from Gerald Joshua who had investigated the use of SharedStreets for City of Austin Data Lake efforts.

The next steps, should SharedStreets IDs be utilized for City of Austin efforts, are to leverage this work, create an API and data store for SharedStreets data, and then incorporate IDs into the Data Lake ETL processes.

## Introductory Notes

Based on what I have seen so far, both from their implementation code as well as their documentation, SharedStreets is intended more for describing a street/road (from both endpoints of the street and other points along the street) than a single point in a map. Besides that, it's also mentioned in their documentation that "SharedStreets is premised on the idea that there's no one correct geometry for a given street. Just as street references can be generated from any basemap, street geometries can be derived from any data source." It's probably why they require us to specify the zoom-tile-level so that points generated for long roads, like highways, will be few if we set the zoom-tile-level to be big. 

In addition, it seems the way we're supposed to use SharedStreets is in one way direction meaning that once our dataset is converted to SharedStreets dataset, there is no distinct way to convert it back to our original dataset. Probably, the reason they did that is to minimize privacy issues, and that way, people can share their data between institutions. Besides that, they appear to be calling their own API to generate the intersection IDs as well as the points along the street. I noticed from the comment section of the code that they did MD5 hashing to the intersection points and only took the first 32 characters of that generated MD5 characters. (Further info may be found in [https://github.com/sharedstreets/sharedstreets-ref-system](https://github.com/sharedstreets/sharedstreets-ref-system)). Their API looks something like this: [https://tiles.sharedstreets.io/osm/planet-180312/{z}-{x}-{y}.{layer}.6.pbf](https://tiles.sharedstreets.io/osm/planet-180312/{z}-{x}-{y}.{layer}.6.pbf), where *z* is the zoom level, *x* and *y* are the tile-coordinates, and *layer* is either geometry, intersection, reference, or metadata.

## Further Notes

As for the SharedStreets, it turns out that they only support tile coordinates (which is also a part of OpenStreetMap convention) instead of regular coordinates. So here are some steps I found useful to do that whole process:
1. First, pick our interested tile zoom level. We can refer to https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Zoom_levels about the tile zoom level. I put a summary of the tile zoom level from my documentation: "A zero-zoom level means 1 tile will cover the entire world while a 19-zoom level means 274.9 billion tiles will cover the entire world. The lower the tile zoom number is the more data will be generated by Sharedstreets."
2. Second, convert our regular x and y coordinates to tile coordinates. They specified in here: https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Implementations
3. Get the GeoJSON (or SharedStreets data) based on those three arguments: the first arg is the zoom level, the second arg is the tile x-coordinate, the third arg is the tile y-coordinate.

## Running the Code

This refers to the working code that is reprinted below, which can be a starting point for making a library. After setting up a virtual environment:

1. Create an object of SharedStreets and pass three parameters - lat, long, tile_zoom_level, e.g.:
    * tile_zoom_level = 12
    * latitude = 30.23
    * longitude = -97.77
    * sharedStreetObj = sharedStreet(latitude, longitude, tile_zoom_level)

    Notice that I set tile zoom level to be 12. It's the optimal level based on my experience so far. Level 1 covers the entire world. The goal is to generate a tile that is big enough to make our data reliable. But also, having a tile zoom level too small will make the generated tile too big which means our end will not have capacity or memory buffer to receive it. This will lead to a data leak.  

2. Print SharedStreets intersection ID based on that lat, long. There are two ways to get the intersection ID. It's either from the database or SharedStreets API, e.g.:
    + From database, for instance: print(sharedStreetObj.getIntersectionID("postgress"))
    + Two ways from Sharedstreets API:
        > print( sharedStreetObj.getIntersectionID("sharedstreets")) or print( sharedStreetObj.getIntersectionID())

5. Similarly, to print SharedStreets street ID based on that lat, long. There are two ways to get that ID. It's either from the database or Sharedstreets API, e.g.:
    + From the database, for instance: print(sharedStreetObj.getGeometryID("postgress"))
    + Two ways from Sharedstreets API:
        > print( sharedStreetObj.getGeometryID("sharedstreets")) or print( sharedStreetObj.getGeometryID())

6. Currently, the database is only filled from one tile. To keep populating the database:
sharedStreetObj.cacheAllTilesInAustin() 
    > * There might be some error messages generated because of duplicates. Just ignore it.

## Working Code

This is the latest code that was referened in this document. The "sharedstreets" dependency comes from [https://github.com/sharedstreets/sharedstreets-python](https://github.com/sharedstreets/sharedstreets-python).

```python
import sharedstreets.tile
import math
import json
import geopy.distance
import geojsonio
import geopandas
import psycopg2

class sharedStreet():
	def __init__(self, latitude, longitude, tile_zoom_level=19):
		self.__latitude = latitude
		self.__longitude = longitude
		self.__tile_zoom_level = tile_zoom_level
		tile_coordinates = self.__deg2num(latitude, longitude, tile_zoom_level)
		self.__x_tile_coordinate = tile_coordinates[0]
		self.__y_tile_coordinate = tile_coordinates[1]
		self.__db_conn_params = "dbname={} user={} host={} port={} password={}".format(
                                "postgres", "****", "localhost", 5400, "****")

	#Convert regular map coordinates into tile coordinates based on tile_zoom_level
	def __deg2num(self, latitude, longitude, tile_zoom_level):
		lat_rad = math.radians(latitude)
		n = 2.0 ** tile_zoom_level
		xtile = int((longitude + 180.0) / 360.0 * n)
		ytile = int((1.0 - math.asinh(math.tan(lat_rad)) / math.pi) / 2.0 * n)
		return (xtile, ytile)

	#Get the distance (in miles) between two points using geodesic distance	
	def __distanceTwoPoints(self, coordinate1, coordinate2):
		return geopy.distance.distance(coordinate1, coordinate2).miles

	#Cache geojson in city of Austin to database
	def __insert_austin_geojson_to_database(self, geojson, thePoint):
		try:
			success = True
			conn = None
			cursor = None
			command = "INSERT INTO {} (point, geojson) VALUES (ST_POINT({}, {}), {});".format(
				"sharedstreet_austin_geojsons", thePoint[1], thePoint[0], json.dumps(json.dumps(geojson)))
			conn = psycopg2.connect(self.__db_conn_params)
			cursor = conn.cursor()
			cursor.execute(command)
			conn.commit()
		except Exception as err:
			print(str(err))
			success = False
		finally:
			if(conn):
				conn.close()
				cursor.close()

			return success

	#Insert GeoJSON to PSQL Database
	def __insert_to_database(self, geojson, intersection_id):
		try:
			success = True
			command = "INSERT INTO {} (intersection_id, geojson, set_of_points) VALUES ('{}', '{}', ST_POINT({}, {}));".format(
				"sharedstreet_intersections", intersection_id, json.dumps(geojson), self.__longitude, self.__latitude)
			conn = psycopg2.connect(self.__db_conn_params)
			cursor = conn.cursor()
			cursor.execute(command)
			conn.commit()
		except Exception as err:
			print(str(err))
			conn = None
			success = False
		finally:
			if(conn):
	            		conn.close()
	            		cursor.close()

			return success
			
	#Check if a specific intersection ID exists
	def __check_if_intersection_id_exists(self, intersection_id):
		try:
			found = False
			conn = None
			cursor = None
			command = "SELECT EXISTS (SELECT {} FROM {} WHERE {} = '{}');".format(
				"intersection_id", "sharedstreet_intersections", "intersection_id", intersection_id)
			conn = psycopg2.connect(self.__db_conn_params)
			cursor = conn.cursor()
			cursor.execute(command)
			found = cursor.fetchone()[0]
		except Exception as err:
			print(str(err))
			found = False
		finally:
			if(cursor):
				cursor.close()
			if(conn):
				conn.close()
			return found

	#Add more points to the existing data based on the intersection ID
	def __update__the_existing_data(self, curIntersectionID):
		try:
			success = True
			conn = None
			cursor = None
			command = "UPDATE {} SET {} = ST_AddPoint({}, ST_Point({}, {}));".format(
                                "sharedstreet_intersections", "set_of_points", "set_of_points::geometry", self.__longitude,
				self.__latitude)
			conn = psycopg2.connect(self.__db_conn_params)
			cursor = conn.cursor()
			cursor.execute(command)
			conn.commit()
		except Exception as err:
			print(str(err))
			success = False
		finally:
			if(cursor):
				cursor.close()
			if(conn):
				conn.close()
			return success

	#Select a particular geojson from PSQL database
	def __select_from_database(self):
		try:
			geojson = None
			command = ("SELECT {} FROM {} WHERE ST_DWithin(data_point," + 
					"ST_GeographyFromText('POINT({} {})'), {}) " +
					"ORDER BY ST_Distance(data_point, ST_GeographyFromText('POINT({} {})'))" + 
					"LIMIT 1;").format("metadata", "my_data", self.__longitude, self.__latitude,
					200, self.__longitude, self.__latitude)
			conn = psycopg2.connect(self.__db_conn_params)
			cursor = conn.cursor()
			cursor.execute(command)
			geojson = cursor.fetchone()
		except Exception as err:
			print(str(err))
			conn = None
			geojson = None
		finally:
			if(conn):
                conn.close()
                cursor.close()
			return geojson 

	#Update the latitude and the longitude
	def updateCoordinates(self, latitude, longitude, tile_zoom_level=19):
		self.__latitude = latitude
		self.__longitude = longitude
		self.__tile_zoom_level = tile_zoom_level
		tile_coordinates = self.__deg2num(latitude, longitude, tile_zoom_level)
		self.__x_tile_coordinate = tile_coordinates[0]
		self.__y_tile_coordinate = tile_coordinates[1]

	#Get the current latitude and longitude
	def getCurrentCoordinates(self):
		return (self.__latitude, self.__longitude)

	#Return the Sharedstreet Intersection ID (a string if found, -1 if not found), 
	#	assuming the interested coordinate is near an intersection. 
	#	The parameter 'source' determines the where to get the data from. 
	#	It can be from 'sharedstreets' API or our own 'psql' database. 
	def getIntersectionID(self, source="sharedstreets"):
		curSmallestDistance = -1
		curIntersectionId = -1
		curFeature = {
			"type": "FeatureCollection",
	  		"features": [None]
	  	}

		if(source == "sharedstreets"):
			#Call sharedstreet API through 'sharedstreets' module
			tile = sharedstreets.tile.get_tile(self.__tile_zoom_level, 
				self.__x_tile_coordinate, self.__y_tile_coordinate)
			geojson = sharedstreets.tile.make_geojson(tile)
			
			'''Output the whole geojson to a file in a pretty format 
				for a testing purpose 
			with open("whole_result.json", "w") as geo_json_file:
				json.dump(geojson, geo_json_file, indent=4)
			'''

			for feature in geojson["features"]:
				if(feature["role"] == "SharedStreets:Intersection"):
					longitude, latitude = feature["geometry"]["coordinates"] 
					distance = self.__distanceTwoPoints((self.__latitude, self.__longitude), (latitude, longitude))

					if(curSmallestDistance == -1 or distance < curSmallestDistance):
						curSmallestDistance = distance
						curIntersectionId = feature["id"]
						curFeature["features"][0] = feature

			'''Output the geojson with only the intersection ID to a file  
				for a testing purpose
			with open("result.geojson", "w") as geo_json_file:
				json.dump(curFeature, geo_json_file, indent=4)
			'''

			#Cache the geojson and the intersection ID to the psql database
			if(self.__check_if_intersection_id_exists("abc")):
				if(not(self.__update__the_existing_data("abc"))):
                                	print("Updating the data with Intesection ID - " + str(curIntersectionId) + " was not successful")
			else:	
				print("haha")
			#	if(not(self.__insert_new_data_to_database(curFeature, curIntersectionID))):
			#		print("Insert a new data with Intesection ID - " + str(curIntersectionID) + " was not successful")
					

		#psql as the parameter source
		else:	
			#Check if our database has the interested Intersection ID
                	temp_geojson = self.__select_from_database()
                	if(temp_geojson != None):
                        	curIntersectionId = temp_geojson[0]["features"][0]["id"]					

		return curIntersectionId

	''' For showing a map
	def displayGeoJson(fileName):
		geoJson = geopandas.read_file(fileName)
		geojsonio.display(geoJson)
	'''

	#Get all tiles in Austin and cache it to the database
	def cacheAllTilesInAustin(self):
		#Lower than 12, the geojson generated by sharedStreet will not be
		#	reliable anymore. It may have to do with the size of the
		#	geojson that can be too big.
		tile_zoom_level = 12

		#Points to cover city of Austin
		austinPoints = [(30.256479, -97.759327), (30.206052, -97.789373), 
					(30.201151, -97.859523), (30.285865, -97.820636),
					(30.332573, -97.862904), (30.204804, -97.748781),
					(30.215031, -97.680307), (30.228545, -97.640575),
					(30.273963, -97.703234), (30.273963, -97.703234), 
					(30.348809, -97.683027), (30.369058, -97.735664),
					(30.390427, -97.802806), (30.366246, -97.833444),
					(30.363996, -97.892111), (30.399424, -97.803458),
					(30.425846, -97.836703), (30.396612, -97.735664),
					(30.424159, -97.727190), (30.390427, -97.685960),
					(30.412354, -97.667708), (30.381711, -97.660700),
					(30.354434, -97.612381), (30.489622, -97.785776),
					(30.466589, -97.798814), (30.422754, -97.767524),
					(30.374401, -97.708205), (30.361465, -97.735583),
					(30.350778, -97.769480), (30.318146, -97.820325),
					(30.351903, -97.768176), (30.315332, -97.726457),
					(30.348668, -97.684656), (30.343605, -97.839799),
					(30.312659, -97.860007), (30.301404, -97.670315),
					(30.267630, -97.693131), (30.354856, -97.740065),
					(30.397034, -97.738109), (30.406311, -97.739250),
					(30.396753, -97.696227), (30.405186, -97.651574),
					(30.420927, -97.681234), (30.327289, -97.733872),
					(30.381290, -97.799058) ]

		#Find geojson for each point and cache it to the database immediately
		for austinPoint in austinPoints:
			#Find geojson for each point 
			tile_coordinates = self.__deg2num(austinPoint[0], austinPoint[1], tile_zoom_level)
			x_tile_coordinate = tile_coordinates[0]
			y_tile_coordinate = tile_coordinates[1]
			tile = sharedstreets.tile.get_tile(tile_zoom_level, 
				x_tile_coordinate, y_tile_coordinate)
			geojson = sharedstreets.tile.make_geojson(tile)

			geojson = geojson["features"][0]

			'''Output the geojson with only the intersection ID to a file for a testing purpose'''
			with open("result.geojson", "w") as geo_json_file:
				json.dump(geojson, geo_json_file, indent=4)
			
			return

			#cache geojson to the database
			if(not(self.__insert_austin_geojson_to_database(geojson, austinPoint))):
				print("Fail to cache to the database for point: (" + str(austinPoint[0]) + "," + str(austinPoint[1]) + ")")
			break

if __name__ == '__main__':	
	tile_zoom_level = 19
	latitude = 30.2636
	longitude = -97.7418
	sharedStreetObj = sharedStreet(latitude, longitude, tile_zoom_level)
	sharedStreetObj.cacheAllTilesInAustin()
	#print(sharedStreetObj.getIntersectionID())
```